data.pickle:


f_dists_query_ref - 1935x145
 f_dists_ref_ref - 1935x1935


query['l'] -  145
query['xy'] -  145x2
query['t'] -  145


ref['l'] -  1935
ref['xy'] -  1935x2
ref['t'] -  1935





def get_edges(xy, max_dist, diff_to_path):
""""""Получает элементы с максимальной длиной max_dist из массива координат узла nx2
Этот метод используется для последовательностей, где поэтажный план недоступен."""


KDTree - создание дерева для кластеризации точек (к-д дерево - методика для поиска ближайшей точки за самое кратчайшее время. вместо сравнения с каждым - все точки делятся напр по середине. теперь в начале поиска мы просто смотрим слева или справа будет точка от полосы деления и сравниваем с ними. и так нужное количество)   
причем, мы делим так чтобы проходило конкретно по какой-то точке, например по х -  по х координате точки А1, тогда это наша вершина графа, а дальше деление напр. по y и тд по всем k-точкам )


nn, nn_dists = tree.query_radius - возвращает для каждой точки из XY точки, которые находятся на расстоянии 10 - том, которое указывали в max_dist (т.е. для нулевой точки вернет 1-45, и там расстояния от 0 до 9.93 ) -  т.е. это пункт 4.2, наш kx это nn

потом в каунте считается сумма количества таких близких вершин для всех точек
берется половина  (видимо как ограничение количества вершин)

для i от 0 до количества всех точек (1-1935)
	для каждой j от 0 до количества похожих вершин (1- ~45)
		(ЗНАЧИТ ПЕРЕБИРАЕМ КАЖДУЮ ТОЧКУ ПО И, И ПО ЖИ - ЕЕ ДИСТАНЦИИ ДО ДРУГИХ ПОХОЖИХ)
		если дистанция = 0 , ничего
		если же номер точки меньше чем номер похожей на нее точки
			значит е-тый столбец ВЕРШИН будет [номер точки; номер близкой ей точки]
			и е-тый елемент ДИСТАНЦИИ - дистанция от точки до близкой ей
			
как я понимаю, таким образом мы отсеиваем одинаковые пересечения (т.е. если мы знаем, что точки 1-2 похожи, то мы добавим в вершины только 1-2, зачем нам точно такая же 2-1)

np.delete(arr, obj, axis) - удаление из массива АРР, объектов с индексами ОБЖ, по оси АКСИС
если последнее не указывать, то в итоге будет сплющенный массив - просто вектор, если =1, то удаление по строкам. напр np.delete(а, [1,2], 1) - удалит из а элементы с индексами 1 и 2  из каждой строки. если же 0 третьим аргументом -то удалятся элементы с индексами 1 и 2 в векторе из матрицы А.

np.s_  - делает слайс, т.е. np.s_[e:num_edges] - возвращает слайс от Е до количества вершин. т.е удаляет лишние елементы, которые мы не заполнили в прошлом шаге (т.к изначально создавалась пустая матрица размерности, а могли недозаполнить)

по итогу на данном этапе мы имеем две матрицы - одна из них 23123х2 - где в первой строке вершины, а во второй - близкие к ней в пределах 10, а в матрице дистанций - расстояния от этих точек до других похожих. 



  l = integrate_path(xy)
  
  dx - вектор из 1934 элементов, каждый из которых предсталвяет собой геометрическое расстояение от точки до следующей точки. (по теореме пифагора). т.е. dx[0] - расстояние между 1 и 0 точкой.
  p_sum - из 1935 элементов
  сначала p_sum[1] = dx[0] - 1-2 и последний элемент равен 0.56
  p_sum[1] = p_sum[1]+p_sum[0]
  p_sum[2] = p_sum[2]+p_sum[1]
  значит, конечный это суммарное расстояние между точками, а последний элемент - все суммы расстояний между точками = 299
  
  
  
  to_delete = [i for i in range(len(dists)) if ((l[edges[1, i]] - l[edges[0, i]]) - dists[i]) > diff_to_path]
  
  
  если ((сумма расстояний для похожей точки) - (сумма расстояний до точки, на которую похожи))
  минус дистанция между этими точками) больше чем diff_to_path, значит нужно его удалить
  
  как я понял, это реализация 4.3
  





ПЕРЕХОДИМ К Sample landmarks with flow - Выборочные ориентиры с потоком
 feat_dists = [f_dists_ref_ref[edges[0, i]][edges[1, i]] for i in range(edges.shape[1])]

т.е. по факту мы создаем векториз фьюче-дистансис для каждой вершины и похожей на нее вершины. 

 flow_lm = sample_with_flow(ref['xy'], edges, source_idx, sink_idx, geo_dists, feat_dists, num_landmarks)
 
 равноценно
 
  flow_lm = sample_with_flow(координаты Х У для начальных изображений, Вершины, Первый индекс, Последний индекс, Геометрическое расстояние, Фьюче-дистансис, количество лендмарков, которые нужно определить = 150)
  
 ПУНКТ 5 статьи - Для каждой вершины eij ∈ E которая представляет собой отношения между изображениями Ii and Ij , через flow capacity uij = Вес для геометрического измерения * геометрическое расстояние
и cost rate cij  = Вес для визуального измерения * фьюче дистанс   -----  ЕГо в коде принимают равным 1 =>      feat_dists = feat_dists / statistics.median(feat_dists). 
    			costs = 1. / (1e-6 + feat_dists) 

т.е. сначала приводим вектор в относительную величину (каждое значение относительно медианного), а потом рассчитываем стоимость для каждого.

k-center problem - выделение к-штук центров, вокруг которых можно построить круги радиусом 2r так, чтобы они охватывали точки.


def greedy_anchors(xy, a_dist, a_nn):
    """
    Возвращает индексы якорей и относящихися к ним точек в XY
        n = xy.shape[0] берем все точки
    selected = [random.randrange(n)] выбираем одно случайное число до 1935
    remaining = np.setdiff1d(range(n), selected).tolist() -  весь список кроме выбранной точки)
    
    
    i_max = np.argmax(nn_dists) - возвращает индекс самого большого числа
	по факту цикл находит самые отстоящие точки. и делает из них якоря таким образом, чтобы 
	максимальное расстояние было больше (a_dist / 2), иначе найдены все якоря. 
	
	потом находятся ближайшие к ней а_nn точек. 
	
	итого: anchors = 96, a_nbh = 96х6
	например: anc = 0, 14, 23, 33, ....
	A_NBH =   0    1    2    3    4    5]
 [  14   15   13   16   12   17]
 [  23   24   22   25   21   26]
 
 
     caps = [(T if ((edges[0][i] in special_idx) or (edges[1][i] in special_idx))
             else caps[i]) for i in range(len(caps))]  - принимаем полный входной и выходной потоки равными 0.1
             
             
потом создается направленный граф


def sensitivity(edges, f_dists): - возвращает чувствительность алгоритма сетевого потока

Мы определяем чувствительность, используя распределение признаков вокруг вершины 
Чувствительность способствует распространению потока до
того, как будет использована максимальная пропускная способность самой дешевой вершины Это
особенно важно, когда разнообразный набор визуальных элементов
сгруппирован геометрически. В таких случаях риск заключается
в том, что поток в основном проходит только через одну вершину, таким образом
выбирая только один ориентир, поскольку как входящие, так и исходящие ребра обеспечивают низкую стоимость и достаточную пропускную способность. Это нарушает правило визуального представления. В таких обстоятельствах
чувствительность способствует распространению потока таким образом, что
в соответствии с правилом выбирается более одного ориентира.           
             





